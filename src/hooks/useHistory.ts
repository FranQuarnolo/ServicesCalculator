import { useState, useEffect, useCallback } from 'react';
import type { BillRecord, ServiceType } from '../types';
import { supabase } from '../lib/supabase';

export const useHistory = () => {
    const [records, setRecords] = useState<BillRecord[]>([]);
    const [loading, setLoading] = useState(false);

    const fetchRecords = useCallback(async () => {
        try {
            setLoading(true);
            const { data, error } = await supabase
                .from('bill_records')
                .select('*')
                .order('date', { ascending: false });

            if (error) {
                console.error('Error fetching records:', error);
                return;
            }

            if (data) {
                // Map snake_case DB fields to camelCase TS interface
                const mappedRecords: BillRecord[] = data.map(item => ({
                    id: item.id,
                    type: item.type,
                    date: item.date,
                    periodLabel: item.period_label,
                    billAmount: item.bill_amount,
                    totalConsumption: item.total_consumption,
                    backHouseConsumption: item.back_house_consumption,
                    frontHouseConsumption: item.front_house_consumption,
                    streetReadingPrev: item.street_reading_prev,
                    streetReadingCurr: item.street_reading_curr,
                    internalReadingPrev: item.internal_reading_prev,
                    internalReadingCurr: item.internal_reading_curr,
                    frontHousePay: item.front_house_pay,
                    backHousePay: item.back_house_pay,
                    isPaid: item.is_paid,
                    fileUrl: item.file_url
                }));
                setRecords(mappedRecords);
            }
        } catch (err) {
            console.error('Unexpected error:', err);
        } finally {
            setLoading(false);
        }
    }, []);

    // Fetch on mount
    useEffect(() => {
        fetchRecords();
    }, [fetchRecords]);

    const addRecord = async (record: BillRecord) => {
        // Optimistic update
        setRecords([record, ...records]);

        const { error } = await supabase.from('bill_records').insert({
            type: record.type,
            // id is auto-generated or we can pass it if we want uuid from client
            // but if we used crypto.randomUUID(), we can send it or let DB handle it.
            // If we used the file upload with custom name logic, we don't necessarily need ID there.
            period_label: record.periodLabel,
            bill_amount: record.billAmount,
            total_consumption: record.totalConsumption,
            back_house_consumption: record.backHouseConsumption,
            front_house_consumption: record.frontHouseConsumption,
            street_reading_prev: record.streetReadingPrev,
            street_reading_curr: record.streetReadingCurr,
            internal_reading_prev: record.internalReadingPrev,
            internal_reading_curr: record.internalReadingCurr,
            front_house_pay: record.frontHousePay,
            back_house_pay: record.backHousePay,
            is_paid: record.isPaid,
            file_url: record.fileUrl
        });

        if (error) {
            console.error('Error adding record:', error);
            // Revert optimistic update? For now simple log.
        } else {
            // Fetch to get the true ID if generated by DB, though we sent everything
            fetchRecords();
        }
    };

    const deleteRecord = async (id: string) => {
        const { error } = await supabase.from('bill_records').delete().eq('id', id);
        if (!error) {
            setRecords(records.filter(r => r.id !== id));
        } else {
            console.error('Error deleting:', error);
        }
    };

    const togglePaidStatus = async (id: string) => {
        const record = records.find(r => r.id === id);
        if (!record) return;

        const newStatus = !record.isPaid;

        // Optimistic
        setRecords(records.map(r => r.id === id ? { ...r, isPaid: newStatus } : r));

        const { error } = await supabase
            .from('bill_records')
            .update({ is_paid: newStatus })
            .eq('id', id);

        if (error) console.error('Error updating status:', error);
    };

    const getLatestReadings = async (type: ServiceType) => {
        const { data } = await supabase
            .from('bill_records')
            .select('street_reading_curr, internal_reading_curr')
            .eq('type', type)
            .order('date', { ascending: false })
            .limit(1)
            .single();

        return {
            street: data?.street_reading_curr || 0,
            internal: data?.internal_reading_curr || 0
        };
    };

    return {
        records,
        loading,
        addRecord,
        deleteRecord,
        togglePaidStatus,
        getLatestReadings
    };
};
